<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git笔记</title>
    <url>/posts/git-notes/</url>
    <content><![CDATA[<h2 id="Git简介">Git简介</h2>
<h3 id="Git的诞生">Git的诞生</h3>
<h3 id="集中式vs分布式">集中式vs分布式</h3>
<h2 id="安装Git">安装Git</h2>
<p><strong>在Linux上安装Git</strong></p>
<p>在Debian系上用<code>sudo apt-get install git</code>就可以。</p>
<p>安装完成后，还需要最后一步，在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="创建版本库">创建版本库</h2>
<p>初始化一个Git仓库，使用<code>git init</code>命令。<br>
添加文件到Git仓库，分为两步：</p>
<ul>
<li>第一步，使用<code>git add &lt;file&gt;</code>，可反复使用多次，添加多个文件；</li>
<li>第二步，使用命令<code>git commit -m &quot;注释&quot;</code>，完成</li>
</ul>
<h2 id="时光穿梭机">时光穿梭机</h2>
<ul>
<li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li>
<li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容</li>
</ul>
<h3 id="版本回退">版本回退</h3>
<ul>
<li><code>HEAD</code>指向的版本就是当前版本，上一个版本是<code>HEAD^</code>，上上一个版本是<code>HEAD^^</code>。Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。如果嫌输出信息太多，可以试试<code>git log --pretty=oneline</code></li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<h3 id="工作区和暂存区">工作区和暂存区</h3>
<p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。例如<code>git commit -m &quot;&lt;修改的内容&gt;&quot;</code></p>
<h3 id="管理修改">管理修改</h3>
<p>用<code>git diff HEAD -- file</code>查看工作区的版本库里最新版的区别</p>
<h3 id="撤销修改">撤销修改</h3>
<p>场景1：当改乱了工作区某个文件的内容 想直接丢弃工作区的修改时，可以用<code>git checkout -- file</code>。</p>
<p>场景2：改乱的工作区文件已经添加到了暂存区，想丢弃，先用命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstaged），重新放回工作区；然后用<code>git checkout -- file</code>。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<strong>版本回退</strong>部分，前提时没有推送到远程仓库。</p>
<h3 id="删除文件">删除文件</h3>
<p>用<code>git rm file</code>来删除一个文件。</p>
<h2 id="远程仓库">远程仓库</h2>
<p>前提：已注册<a href="https://github.com/">Github</a></p>
<p>第1步：创建SSH Key。<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>,修建地址换为自己的邮箱地址，回车，yes。正常的话会看到用户主目录下的<code>.ssh</code>目录下找到<code>id_rsa</code>私钥，<code>id_rsa.pub</code>公钥。</p>
<p>第2步：打开Github的设置，增加SSH Key，填上<code>id_rsa.pub</code>文件里的内容。OK！</p>
<h3 id="添加远程仓库">添加远程仓库</h3>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；<br>
关联后，使用命令<code>git push -u origin master</code>第一次推送master分支所有内容；<br>
此后，每次提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；<br>
分布式版本控制系统的最大好处之一是有没有联网都可以正常工作，有网的时候推送一下就同步了。</p>
<h3 id="从远程仓库克隆">从远程仓库克隆</h3>
<p>要克隆一个仓库，首先必须只当仓库的地址，然后使用<code>git clone</code>命令克隆。</p>
<p>Git支持多种协议，包括<code>https</code>，但是通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p>
<h2 id="分支管理">分支管理</h2>
<h3 id="创建与合并分支">创建与合并分支</h3>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code><br>
创建分支：<code>git branch &lt;name&gt;</code><br>
切换分支：<code>git checkout &lt;name&gt;</code><br>
创建+切换分支：<code>git checkout -b &lt;name&gt;</code><br>
合并某分支到当前分支：<code>git merge &lt;name&gt;</code><br>
删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="解决冲突">解决冲突</h3>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h3 id="分支管理策略">分支管理策略</h3>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并后就看不出来曾经做过合并。</p>
<h3 id="BUG分支">BUG分支</h3>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后再<code>git stash pop</code>，恢复现场，恢复的同时也把stash内容删了。</p>
<p>当多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复制定的stash，用命令<code>git stash apply stash@&#123;0&#125;</code>，stash@{0}是查看stash list时那次stash的码。</p>
<h3 id="Feature分支">Feature分支</h3>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强制删除。</p>
<h3 id="多人协作">多人协作</h3>
<p>多人协作的工作模式通常如下：</p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示“no tracking infomation”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<ul>
<li>查看远程库信息，使用<code>git remote -v</code>；</li>
<li>本地分支如果不推送到远程，对其他人就是不可见的；</li>
</ul>
<h2 id="标签管理">标签管理</h2>
<h3 id="创建标签">创建标签</h3>
<ul>
<li>命令<code>git tag &lt;name&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li>
<li><code>git tag -a &lt;tagname&gt; -m &quot;balabala...&quot;</code>可以指定标签信息；</li>
<li><code>git tag -s &lt;tagname&gt; -m &quot;balabala...&quot;</code>可以用PGP签名标签；</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
</ul>
<h3 id="操作标签">操作标签</h3>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签；</li>
</ul>
<h2 id="使用Github">使用Github</h2>
<ul>
<li>在Github上，可以任意Fork开源仓库；</li>
<li>自己拥有Fork后的仓库的读写权限；</li>
<li>可以推送pull request给官方仓库来贡献代码。</li>
</ul>
<h2 id="使用码云">使用码云</h2>
<ul>
<li>码云和Github的使用方法差不多，具体参考上一节<strong>使用Github</strong>；</li>
<li>因为众所周知的原因Github访问速度比较感人，But码云不会，并且是国内的；</li>
<li>有免费的私有仓库，And支持中文，简直是我等英语渣渣的福音；</li>
</ul>
<p>本地库与多个远程库关联，嗯，不想说了，直接看廖雪峰<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000">Git教程</a>这一节吧。</p>
<h2 id="自定义Git">自定义Git</h2>
<h3 id="忽略特殊文件">忽略特殊文件</h3>
<ul>
<li>编写<code>.gitignore</code>文件，把要忽略的文件名填进去，Git就会自动忽略这些文件。<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 上的稍微改一下就可以用了</li>
<li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理</li>
</ul>
<p>忽略文件的原则：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等；</li>
<li>忽略带有自己敏感信息的配置文件；</li>
</ol>
<h3 id="配置别名">配置别名</h3>
<ul>
<li><code>git config --global alias.st status</code>表示用<code>st</code>作为<code>status</code>的别名，以后敲<code>git st</code>就可以了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br brach</span><br><span class="line">git config --global alias.last <span class="string">&#x27;log -1&#x27;</span>     //用`git last`显示最后一次提的交</span><br><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span>     //查看提交历史，丧心病狂版</span><br></pre></td></tr></table></figure>
<h2 id="搭建Git服务器">搭建Git服务器</h2>
<ul>
<li>
<p>搭建Git服务器，参考<a href="https://github.com/sitaramc/gitolite">教程原文</a>；</p>
</li>
<li>
<p>要方便管理公钥，用<a href="https://github.com/sitaramc/gitolite">Gitosis</a>；</p>
</li>
<li>
<p>要像SVN那样变态控制权限，用 Gitolite；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java问题排查</title>
    <url>/posts/java-troubleshooting/</url>
    <content><![CDATA[<h2 id="排查业务问题">排查业务问题</h2>
<ol>
<li>采用<code>tail -fn 200 log_file </code>实时查询线上日志</li>
<li>找准日志搜索关键字 keyWord，例如 orderid、mobileId、reqId 等</li>
<li>采用<code>grep keyWord log_file</code>查询关键字所在行的日志</li>
<li>采用 <code>grep -C n keyWord log_file</code>匹配关键字所在行的上下 n 行</li>
<li>采用<code>grep keyWord log_file | wc -l</code>匹配关键字的行数有多少</li>
<li>根据实际排查日志场景进行搜索 tail、grep 用的最多</li>
</ol>
<h2 id="线上应用-CPU-占用过高">线上应用 CPU 占用过高</h2>
<ol>
<li>采用<code>top</code>命令，找出 CPU 占用最高的 PID</li>
<li>通过<code>ps -ef | grep PID</code>查看对应的应用</li>
<li>采用<code>jstack -l PID &gt;&gt; PID.log</code>获取进程额堆栈信息</li>
<li>采用<code>ps -mp PID -o THREAD,tid,time</code>拿到占用 CPU 最高的 tid</li>
<li>采用<code>printf “%x\n” tid</code>获取 16 进制的线程 TID</li>
<li>采用<code>grep TID -A20 PID.log</code>确定是线程哪里除了问题</li>
<li>腿疼医腿，辩证施治，对症下药，找准代码位置，进行调整代码</li>
</ol>
<h2 id="线上应用内存溢出">线上应用内存溢出</h2>
<ol>
<li>
<p>采用<code>top</code>命令，找出对应的 PID</p>
</li>
<li>
<p>采用<code>jmap -heap PID</code>确认一下分配的内存少不少</p>
</li>
<li>
<p>采用<code>jmap -histo:live PID | more</code>找出分析最耗内存的对象</p>
</li>
<li>
<p>采用<code>ps -efL | grep PID | wc -l</code>查看进程创建的线程数</p>
</li>
<li>
<p>采用<code>ls -l /proc/PID/task | wc -l</code>也可以查看进程创建的线程数</p>
</li>
<li>
<p>采用<code>netstat -apn | grep 4532 | wc -l</code>查看进程网络连接数</p>
</li>
<li>
<p>腿疼医腿，辩证施治，对症下药</p>
<p>a. 内存分配确实小，适当调整内存；</p>
<p>b. 对象被频繁创建，且不释放，优化代码；</p>
<p>c. 不断创建线程或者不断进行网络连接，优化代码。</p>
</li>
</ol>
<h2 id="工具">工具</h2>
<h3 id="JDK-自带工具">JDK 自带工具</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>查看 java 进程概述</td>
</tr>
<tr>
<td>jconsole</td>
<td>图形化查看内存线程 VM 参数等信息</td>
</tr>
<tr>
<td>jstat</td>
<td>查看内存使用状况</td>
</tr>
<tr>
<td>jstack</td>
<td>分析线程</td>
</tr>
<tr>
<td>jmap</td>
<td>查看内存信息或 dump 下内存详情</td>
</tr>
<tr>
<td>jvisualvm</td>
<td>图形化工具，功能在 jconsole 之上</td>
</tr>
</tbody>
</table>
<h3 id="第三方工具">第三方工具</h3>
<p>Arthas，官网 <a href="https://arthas.aliyun.com">https://arthas.aliyun.com</a>，功能强大，常用命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>dump</td>
<td>将已加载的字节码文件保存到特定的目录中</td>
</tr>
<tr>
<td>classloader</td>
<td>获取类加载器的信息</td>
</tr>
<tr>
<td>monitor</td>
<td>监控指定类种方法的执行情况</td>
</tr>
<tr>
<td>watch</td>
<td>观察指定方法的调用情况</td>
</tr>
<tr>
<td>trace</td>
<td>对方法内部调用路径进行追踪，并输出方法路径上每个节点上耗时</td>
</tr>
<tr>
<td>stack</td>
<td>输出当前方法被调用的路径</td>
</tr>
<tr>
<td>tt</td>
<td>记录指定方法每次调用的入参和返回的信息</td>
</tr>
<tr>
<td>options</td>
<td>全局开关</td>
</tr>
<tr>
<td>profiler</td>
<td>生成火焰图</td>
</tr>
</tbody>
</table>
<h2 id="性能问题排查思路">性能问题排查思路</h2>
<ol>
<li>设计调优：一个良好的系统设计可以规避很多钱在的性能问题。必须熟悉常用的软件设计方法、设计模式、基本性能组件和常用优化思想。</li>
<li>代码调优：掌握编码技巧、对算法、数据结构的灵活使用。</li>
<li>JVM 调优：JVM 的各项参数会直接影响 Java 程序的性能。</li>
<li>数据库调优：在应用层对 SQL 语句进行优化；对数据库进行优化。</li>
<li>操作系统调优：操作系统的性能对应用系统也有较大影响。</li>
<li>腿疼医腿，辩证施治，对症下药。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux上的OpenVPN搭建</title>
    <url>/posts/OpenVPN-setup/</url>
    <content><![CDATA[<h2 id="1-环境">1. 环境</h2>
<h3 id="1-1-硬件和网络拓扑">1.1 硬件和网络拓扑</h3>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586794884591.png" alt="网络拓扑"></p>
<ul>
<li>
<p>OpenVPN Server：双网卡机器，同时连接大小网，提供 VPN 拨号服务。</p>
</li>
<li>
<p>OpenVPN Client：位于大网，通过拨号，获得小网地址后，可以和小网 PC 互相访问。</p>
</li>
<li>
<p>小网 PC：位于小网（如 192.168 网段）</p>
<blockquote>
<p><strong>注意</strong>：以下 OpenVPN Server 网络配置相关信息仅供参考，并非真实信息。</p>
<p>IP1：10.185.80.57		子网掩码1：255.255.254.0<br>
IP2：192.168.18.6		子网掩码2：255.255.240.0</p>
</blockquote>
</li>
</ul>
<h3 id="1-2-软件要求">1.2 软件要求</h3>
<p>操作系统：Centos 7<br>
第三方包：所有软件包均通过 yum 在线安装</p>
<h2 id="2-安装配置-OpenVPN-服务端">2.安装配置 OpenVPN 服务端</h2>
<h3 id="2-1-配置-yum-源">2.1 配置 yum 源</h3>
<p>由于 rpm 包安装需要的依赖关系可能比较繁杂，这里选用 yum 在线安装。</p>
<h4 id="2-1-1-配置-Centos-源">2.1.1 配置 Centos 源</h4>
<p>打开 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/centos/">Centos 清华镜像源</a> ，选择 Centos 7 配置文件，直接使用如下内容覆盖掉<code>/etc/yum.repos.d/CentOS-Base.repo</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7</span><br><span class="line"></span><br><span class="line">#released updates</span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-$releasever - Updates</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7</span><br><span class="line"></span><br><span class="line">#additional packages that may be useful</span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-$releasever - Extras</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7</span><br><span class="line"></span><br><span class="line">#additional packages that extend functionality of existing packages</span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-$releasever - Plus</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7</span><br></pre></td></tr></table></figure>
<p>然后缓存元数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-配置-EPEL-源">2.1.2 配置 EPEL 源</h4>
<p>openvpn 在 EPEL 仓库中，所以需要配置 EPEL 源。这里参考<a href="https://mirrors.tuna.tsinghua.edu.cn/help/epel/">清华镜像源epel帮助</a>，在<code>/etc/yum.repos.d</code>目录下增加“epel.repo”文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[epel]</span><br><span class="line">name=Extra Packages for Enterprise Linux 7 - $basearch</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/$basearch</span><br><span class="line">#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line"></span><br><span class="line">[epel-debuginfo]</span><br><span class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Debug</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/$basearch/debug</span><br><span class="line">#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;arch=$basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line">gpgcheck=1</span><br><span class="line"></span><br><span class="line">[epel-source]</span><br><span class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Source</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/SRPMS</span><br><span class="line">#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;arch=$basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line">gpgcheck=1</span><br></pre></td></tr></table></figure>
<p>然后执行下面的命令，缓存元数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
<h3 id="2-2-安装相关软件包">2.2 安装相关软件包</h3>
<p>执行如下命令，一次性完成安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install lzo openssl easy-rsa openvpn</span><br></pre></td></tr></table></figure>
<p>安装后，easy-rsa 的相关文件存放于<code>/usr/share/easy-rsa/3.0.3</code>和<code>/usr/share/doc/easy-rsa-3.0.3</code>两个路径下，需要把 easy-rsa 的相关文件放到一个目录，以便后面的操作， 这里我放到<code>/root/EasyRSA-3.0.3/</code>目录。操作如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /root/EasyRSA-3.0.3</span><br><span class="line">cp -a /usr/share/easy-rsa/3.0.3/* /root/EasyRSA-3.0.3</span><br><span class="line">cp -a /usr/share/doc/easy-rsa-3.0.3/* /root/EasyRSA-3.0.3</span><br></pre></td></tr></table></figure>
<p>操作完成后，目录中的内容如下</p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795038260.png" alt="easy-rsa的相关文件"></p>
<h3 id="2-3-制作-server-端证书">2.3 制作 server 端证书</h3>
<p>制作证书需要一个目录，（我这里以<code>/etc/openvpn/</code>目录为 server 端根目录），执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /root/EasyRSA-3.0.3 /etc/openvpn/	# 复制一份给server端，用于生成客户端证书</span><br><span class="line">cd /etc/openvpn/EasyRSA-3.0.3</span><br><span class="line">cp vars.example vars                  # 复制一份样例，准备修改</span><br><span class="line">vim vars                              # 修改样例</span><br></pre></td></tr></table></figure>
<p>修改下 EasyRSA-3.0.3 目录下的 vars 这个文件，配置下环境变量，这里配置了主要是方便在后面制作证书的过程中不用输入很多信息，比较方便，我这里的配置如下图，业务可根据需求自行配置。</p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795146203.png" alt="vars编辑内容"></p>
<p>vars 这个文件修改完毕之后，需要 source 一下，再把证书系统初始化，操作如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source vars                     # 把var里面的值写入到环境变量中去</span><br><span class="line">./easyrsa init-pki              # 初始化证书生成环境</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795181625.png" alt="初始化证书系统"></p>
<p>下一步就是制作 CA 证书了，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa build-ca				# 制作ca证书</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795209619.png" alt="CA证书制作"></p>
<p>这里会要求出入一个 CA 证书的密码，可以不用输入，我这里输入的 CA 密码为 123456，同时设置 CA 的 Common Name 为 puma。</p>
<p><strong>注意：这里CA的这个密码 123456 要记住，因为后续进行 server 证书和 client 证书认证的时候都需要输入这个密码的。如果忘记，需用重新制作根证书。</strong></p>
<p>下一步就是生成server端的证书了，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa gen-req server nopass	# 生成server端证书，需要输入server端的CommonName，可以自行设置</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586799570954.png" alt="生成server端证书"></p>
<p>我这里配置的服务器的名字为 server，服务器证书的 Common Name 为 puma_server</p>
<p>接下来需要对服务器端的证书进行签名认证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa sign server server	# 认证server端证书，需要前面设置的 CA 密码</span><br></pre></td></tr></table></figure>
<p><strong>注意：认证证书时需要输入CA的密码</strong>，我这里输入 123456，可以看到，认证成功了。</p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795264163.png" alt="签名认证server端证书"></p>
<p>最后一步就是生成 Diffie-Hellman 文件了，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa gen-dh				# 生成 dh 证书</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795296654.png" alt="生成dh证书"></p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795322693.png" alt="dh证书生成成功"></p>
<p>完成后如上图。到这里，server 端的证书和根证书就都生成了，我们把它们拷贝到一个目录下，方便后续 openvpn 的配置文件进行配置。这里把需要用到的证书都拷贝到 <code>/etc/openvpn/server</code> 目录下，操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/openvpn/EasyRSA-3.0.3</span><br><span class="line">cp pki/ca.crt ../server/</span><br><span class="line">cp pki/issued/server.crt ../server/</span><br><span class="line">cp pki/private/server.key ../server/</span><br><span class="line">cp pki/dh.pem ../server/</span><br><span class="line">mv /etc/openvpn/server/dh.pem ../server/dh2048.pem	# 根据vars文件中的设置，改名为dh2048.pem</span><br></pre></td></tr></table></figure>
<p>执行完成后，<code>/etc/openvpn/server</code>目录下应该有4个文件</p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795375667.png" alt="server目录下的文件"></p>
<h3 id="2-4-配置-server-端配置文件">2.4 配置 server 端配置文件</h3>
<p>执行如下命令写配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/openvpn/server/</span><br><span class="line">vim server.conf					# 创建 server 端配置文件并编辑，文件内容如下</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 强烈建议配置文件中用绝对路径</span><br><span class="line">port 1194                               # 监听1194端口</span><br><span class="line">proto udp                               # 使用udp协议</span><br><span class="line">dev tun                                 # 通信隧道类型为路由IP隧道</span><br><span class="line">ca /etc/openvpn/server/ca.crt</span><br><span class="line">cert /etc/openvpn/server/server.crt</span><br><span class="line">key /etc/openvpn/server/server.key</span><br><span class="line">dh /etc/openvpn/server/dh2048.pem       # 2048位密钥</span><br><span class="line">server 10.9.0.0 255.255.255.0           # 分配的ip地址区间</span><br><span class="line">ifconfig-pool-persist /etc/openvpn/server/ipp.txt</span><br><span class="line">push &quot;route 192.168.16.0 255.255.240.0&quot; # 给客户端推送路由信息</span><br><span class="line">client-to-client                        # 客户端之间可以互相发现</span><br><span class="line">duplicate-cn                            # 开启证书复用</span><br><span class="line">keepalive 10 120</span><br><span class="line">comp-lzo                                # 启用lzo压缩算法</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">status /etc/openvpn/server/openvpn-status.log</span><br><span class="line">verb 3                                  # 设置日志文件的冗余级别</span><br><span class="line">explicit-exit-notify 1                  # 设置服务器重启时通知客户端，自动重新连接</span><br><span class="line">auth-user-pass-verify /etc/openvpn/server/checkpsw.sh via-env	# 服务端认证</span><br><span class="line">;client-cert-not-required               # 不要求客户端证书</span><br><span class="line">verify-client-cert                      # 要求客户端证书</span><br><span class="line">username-as-common-name</span><br><span class="line">script-security 3                       # 安全等级 3</span><br></pre></td></tr></table></figure>
<p>上面的配置中我们把用户名密码校验交给了<code>checkpsw.sh</code>，现在写一个校验脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/openvpn/server/</span><br><span class="line">vim checkpsw.sh					# 创建校验脚本，文件内容如下</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line">PASSFILE=<span class="string">&quot;/etc/openvpn/server/psw-file&quot;</span></span><br><span class="line">LOG_FILE=<span class="string">&quot;/etc/openvpn/server/openvpn-password.log&quot;</span></span><br><span class="line">TIME_STAMP=`<span class="built_in">date</span> <span class="string">&quot;+%Y-%m-%d %T&quot;</span>`</span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -r <span class="string">&quot;<span class="variable">$&#123;PASSFILE&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;TIME_STAMP&#125;</span>: Could not open password file \&quot;<span class="variable">$&#123;PASSFILE&#125;</span>\&quot; for reading.&quot;</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">CORRECT_PASSWORD=`awk <span class="string">&#x27;!/^;/&amp;&amp;!/^#/&amp;&amp;$1==&quot;&#x27;</span><span class="variable">$&#123;username&#125;</span><span class="string">&#x27;&quot;&#123;print $2;exit&#125;&#x27;</span> <span class="variable">$&#123;PASSFILE&#125;</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;CORRECT_PASSWORD&#125;</span>&quot;</span> = <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;TIME_STAMP&#125;</span>: User does not exist: username=\&quot;<span class="variable">$&#123;username&#125;</span>\&quot;, password=\&quot;<span class="variable">$&#123;password&#125;</span>\&quot;.&quot;</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;password&#125;</span>&quot;</span> = <span class="string">&quot;<span class="variable">$&#123;CORRECT_PASSWORD&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;TIME_STAMP&#125;</span>: Successful authentication: username=\&quot;<span class="variable">$&#123;username&#125;</span>\&quot;.&quot;</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;TIME_STAMP&#125;</span>: Incorrect password: username=\&quot;<span class="variable">$&#123;username&#125;</span>\&quot;, password=\&quot;<span class="variable">$&#123;password&#125;</span>\&quot;.&quot;</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure>
<p>保存后，给脚本加上可执行权限。接着编写 psw-file 文件，其中保存着已授权的用户名和密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x checkpsw.sh</span><br><span class="line">vim psw-file					# 编写psw-file文件，内容如下</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名1 密码1</span><br><span class="line">用户名2 密码2</span><br></pre></td></tr></table></figure>
<p>执行如下命令配置 iptables 的 NAT 转发</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -j MASQUERADE</span><br></pre></td></tr></table></figure>
<p>在 openvpn-server 机器上，编辑<code>/etc/sysctl.conf</code>文件，加入<code>net.ipv4.ip_forward=1</code>到该文件中并保存，开启操作系统的网关转发功能，操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795411956.png" alt="启用系统的网关转发功能"></p>
<p>修改完成并保存后就运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -p       # 使 /etc/sysctl.conf 配置文件里面的配置生效</span><br></pre></td></tr></table></figure>
<h3 id="2-5-启动-server-端">2.5 启动 server 端</h3>
<p>执行如下命令启动 openvpn 服务端，如图，表示启动成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openvpn --config /etc/openvpn/server/server.conf</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795443042.png" alt="server端启动成功"></p>
<blockquote>
<p>注意：OpenVPN 启动后会占用终端，按<code>Ctrl+C</code>停止运行。如果想启动后不占用终端，可加上<code>--daemon</code>参数，如此，启动命令则为：<code>openvpn --daemon --config /etc/openvpn/server/server.conf</code></p>
</blockquote>
<h3 id="2-6-设置-OpenVPN-开机自启（可选）">2.6 设置 OpenVPN 开机自启（可选）</h3>
<p>服务端的安装配置到上一节就完了，为了避免服务器重启后需要手动开启 OpenVPN，这里将其设置为开机自启动，请根据需要选择。</p>
<p>进入到 <code>/etc/rc.d/</code>目录下，编辑 rc.local 文件，操作命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/rc.d/</span><br><span class="line">vim rc.local</span><br></pre></td></tr></table></figure>
<p>在 rc.local 文件中新增下列内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OpenVPN start</span></span><br><span class="line">openvpn --daemon --config /etc/openvpn/server/server.conf &gt; /dev/null</span><br><span class="line">if [ $? -ne 0 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;`date &quot;+%Y-%m-%d %H:%M:%S&quot;` start vpn failed in /etc/rc.d/rc.local&quot; &gt;&gt; /etc/openvpn/server/openvpn-status.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>保存后，修改系统时区和时间，使打印到日志中的时间和本地计算机的时间同步，执行操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">timedatectl set-timezone Asia/Shanghai	# 设置时区为上海</span><br><span class="line">date -s 10:23:30    # 设置为自己本机时间</span><br></pre></td></tr></table></figure>
<h2 id="3-安装配置-OpenVPN-的客户端">3. 安装配置 OpenVPN 的客户端</h2>
<h3 id="3-1-制作-client-端证书">3.1 制作 client 端证书</h3>
<p>client 端证书的制作过程和 server 端的相似，要注意 client 端制作证书的目录和 server 端并非同一个目录。我用来给client 端制作证书的目录：<code>/root/EasyRSA-3.0.3</code>，给server 端则是：<code>/etc/openvpn/EasyRSA-3.0.3</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/EasyRSA-3.0.3/					# 进入客户端证书制作目录</span><br><span class="line">./easyrsa init-pki						# 初始化客户端证书制作目录</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795473382.png" alt="client端证书制作目录初始化"></p>
<p>创建客户端证书，下面是创建成功的截图，client 的名字为 client_xushan，CommonName 为 puma_client_xushan</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa gen-req client_xushan nopass	# 生成client端证书，需要输入client端的CommonName，可自行设置，可设置密码</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795510577.png" alt="生成client端证书"></p>
<p>创建成功后，会在<code>pki/reqs/</code>目录下生成一个名为 client_xushan.req 的文件。</p>
<p>下一步就是在 server 端所在的目录里把上一步生成的 client_xushan.req 这个证书进行签约。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/openvpn/EasyRSA-3.0.3</span><br><span class="line">./easyrsa import-req /root/EasyRSA-3.0.3/pki/reqs/client_xushan.req client_xushan #导入客户端证书</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795536171.png" alt="导入client端证书"></p>
<p>客户端证书签约完成后，还需要进行最后一步的认证，认证之后就可以使用了，过程如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa sign client client_xushan		# 认证客户端证书</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795578907.png" alt="认证client端证书"></p>
<p>到这里，客户端的证书就生成完成了，我们需要把他们拷贝到一个文件夹下，方便后续的使用，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把客户端需要的文件统一放到 /etc/openvpn/client 下</span></span><br><span class="line">cp pki/ca.crt ../client</span><br><span class="line">cp pki/issued/client_xushan.crt ../client</span><br><span class="line">cp /root/EasyRSA-3.0.3/pki/private/client_xushan.key ../client</span><br></pre></td></tr></table></figure>
<p>至此，client 目录下有3个文件<code>ca.crt</code>、<code>client_xushan.crt</code>、<code>client_xushan.key</code>，将 client 目录下载到本地（windows）。</p>
<h3 id="3-2-client-端安装">3.2 client 端安装</h3>
<p>客户端一般是 windows，组件全选安装。安装后桌面会有<code>OpenVPN GUI</code>的快捷方式。<img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795604321.png" alt="icon"></p>
<h3 id="3-3-制作-client-端配置文件">3.3 制作 client 端配置文件</h3>
<p>在本地（windows）创建 .ovpn的配置文件，名字随便起，这里我的是<code>10.185.80.57.ovpn</code>，配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client                    # 表示当前是客户端</span><br><span class="line">dev tun                   # tun 模式（路由模式）</span><br><span class="line">proto udp                 # 使用 udp 协议</span><br><span class="line">remote 10.185.80.57 1194	# 服务器端的ip和端口</span><br><span class="line">resolv-retry infinite     # 断后尝试重连</span><br><span class="line">nobind</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">ca ca.crt</span><br><span class="line">cert client.crt</span><br><span class="line">key client.key</span><br><span class="line">auth-user-pass            # 密码认证</span><br><span class="line">remote-cert-tls server</span><br><span class="line">comp-lzo                  # 启用lzo压缩算法，与server端保持一致</span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure>
<p>根据配置文件，修改<code>client_xushan.crt</code>文件名为<code>client.crt</code>、修改<code>client_xushan.key</code>文件名为<code>client.key</code>保存后，放到刚下载的 client 文件夹下，把 client 文件夹改名成<code>10.185.80.57</code>。将整个文件夹放在 OpenVPN的安装目录下的 config 文件夹下，启动客户端，选择当前配置，输入用户名和密码后会连接上（必须在 server 端中已授权），如图，连接成功</p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795642344.png" alt="客户端连接"></p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/1586795685665.png" alt="客户端分配的ip"></p>
<p>【可选配置】</p>
<p>如不想经常输入用户名和密码，可打开客户端ovpn配置文件，将<code>auth-user-pass</code>改成<code>auth-user-pass pass.txt</code>。同时在相同路径下新增一个名为<code>pass.txt</code>的文本文件。<br>
内容为两行，第一行为 VPN 用户名，第二行为密码。<br>
重新运行 OpenVPN 客户端，即可不输入密码登录 VPN 了！</p>
<hr>
<blockquote>
<p>参考：</p>
<ol>
<li>完整CentOS搭建OpenVPN服务环境图文教程.老左博客</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>OpenVPN</tag>
      </tags>
  </entry>
  <entry>
    <title>博客迁移说明</title>
    <url>/posts/blog-migration-notes/</url>
    <content><![CDATA[<p>最早接触的是 8 年前的 Cmd Markdown，十分优秀的产品。也是看着它的语法手册，学会了 Markdown 语法。后来作者没怎么更新，以为放弃了。用过 Hexo，也用过 Gridea，感觉 yilia 之类的主题差点意思便上手去改，没写多少东西，倒是学了学 EJS 和 Less。去年 Cmd Markdown 被以有违规内容为由停掉，笔记博客类的后起之秀层出不群但大多要被审查。虽然不会有什么出格言论，癞蛤蟆趴脚面，不咬人、膈应人，遂重新搭建。</p>
<h2 id="思路">思路</h2>
<ul>
<li>静态生成器/博客框架：Hexo</li>
<li>CI/CD：Github 私有仓库(源码) + 公开仓库(成品) + action，本地/在线编写，提交到远端自动构建部署</li>
<li>托管：Github Pages</li>
<li>优化：使用 Imgbot 自动压缩图片，还访问慢的话就 CDN + 部署到 Netlify（以后再说）</li>
</ul>
<p>本着能白嫖就白嫖的原则，选用上述方案。</p>
<h2 id="过程">过程</h2>
<p><strong>本篇只是记录过程中的关键点，并不会手把手教搭建部署。</strong></p>
<p>初始化博客仓库，将主题作为 git 子模块，更新 Hexo 框架时同步更新主题，涉及的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加主题作为子模块</span></span><br><span class="line">git submodule add -b 指定分支 主题的仓库地址 主题存放目录</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">出错的话使用下面命令，删除对主题目录下文件的追踪</span></span><br><span class="line">git rm --cached 主题目录</span><br></pre></td></tr></table></figure>
<p>利用 action CI/CD，需要在博客仓库下建一个<code>.github/workflows/gh-page.yml</code>，内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span>   <span class="comment"># 推送到main分支时触发</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy-gh-pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span>  <span class="comment"># 运行环境</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span>       <span class="comment"># 写权限</span></span><br><span class="line">    <span class="attr">concurrency:</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.workflow</span> <span class="string">&#125;&#125;-$&#123;&#123;</span> <span class="string">github.ref</span> <span class="string">&#125;&#125;</span>  <span class="comment"># 并发组控制，保证同时只能有一个job跑</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="string">recursive</span>  <span class="comment"># 获取子模块最新主题，true/recursive</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">~/.npm</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-node-</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="comment"># 用法 https://github.com/marketplace/actions/github-pages-action</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v4</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">github.ref</span> <span class="string">==</span> <span class="string">&#x27;refs/heads/main&#x27;</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 部署密钥，需要手动生成密钥对，私有库用私钥，公开库用公钥，具体操作见上面网址</span></span><br><span class="line">          <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACTIONS_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">external_repository:</span> <span class="string">username/external-repository</span>  <span class="comment"># 部署到的外部仓库</span></span><br><span class="line">          <span class="attr">publish_branch:</span> <span class="string">main</span>  <span class="comment"># 部署分支</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span> <span class="comment"># 发布目录</span></span><br><span class="line">          <span class="attr">user_name:</span> <span class="string">&#x27;github-actions[bot]&#x27;</span>  <span class="comment"># 指定部署用户名</span></span><br><span class="line">          <span class="attr">user_email:</span> <span class="string">&#x27;github-actions[bot]@users.noreply.github.com&#x27;</span> <span class="comment"># 指定部署邮箱</span></span><br><span class="line">          <span class="attr">commit_message:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span>    <span class="comment"># 部署提交消息使用推送时的信息</span></span><br></pre></td></tr></table></figure>
<p>Hexo 搭建博客的细节没有讲，参考下面两篇文章或者网上类似文章，大差不差：</p>
<ul>
<li>
<p><a href="https://krislinzhao.github.io/docs/create-a-wesite-using-github-pages-and-hugo/">如何用 GitHub Pages + Hugo 搭建个人博客</a></p>
</li>
<li>
<p><a href="https://chiujun.github.io/posts/6f0712da.html">一键部署 Hexo 博客到 GitHub Pages</a></p>
</li>
</ul>
<p>Imgbot 是一个 github app，可以用来优化仓库中的图片尺寸，具体参考<a href="https://liangyuanpeng.com/post/add-imgbot-for-your-blog-image/">为你的博客添加imgbot优化图片</a>。</p>
<h2 id="待更新">待更新</h2>
<ul>
<li>Imgbot 优化后会生成一个 PR，考虑<a href="https://githubdocs.cn/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/automatically-merging-a-pull-request">自动合并拉取请求</a>，原理也是 action。</li>
<li>优化访问速度，CDN + 部署到 Netlify。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>对山西大同订婚强奸案的思考</title>
    <url>/posts/Thoughts-on-the-Engagement-Rape-Case-in-Datong-Shanxi-Province/</url>
    <content><![CDATA[<p>二审 2025 年 4 月 16 号作出<a href="https://www.news.cn/legal/20250416/e480221dfe524379bee1b9b83169f61b/c.html">判决</a>并<a href="https://www.news.cn/legal/20250416/c266cb71bb764a248d6810e99751b0e8/c.html">答疑</a>，但讨论还在继续，足以说明此案件影响之大。这次才知道，<strong>原来强奸罪不保护男性</strong>！同一个事可从很多角度去看，这几天的报道总的来说是：<strong>传统婚俗观念与法治社会的冲突</strong>、<strong>常识还原事件过程的角度</strong>，<strong>双方博弈的角度</strong>。</p>
<p>总感觉哪里缺了，那到底缺了哪些？缺的是<strong>这种场景下强奸罪的认定</strong>、<strong>女方报警后各环节程序和司法公正</strong>，<strong>社会思潮变迁的角度(常识往往变得局限)</strong>，没有看到相关报道。官方答疑中或避重就轻，或不予回应，而这几种恰恰是热议最多的。</p>
<p>昨晚看到一篇<a href="https://news.china.com/socialgd/10000169/20250417/48224664_all.html">“张捷谈处女膜完整与强奸罪疑罪从无，司法逻辑与民间共识的碰撞”</a>，可能是借张捷说事，姑且一看，兼听则明。 具体细节和疑点上面文章已经说了很多，就不赘述了。看到个最高检发布的典型案例<a href="https://www.spp.gov.cn/spp/xwfbh/wsfbh/202402/t20240226_644761.shtml">“河南省安阳市文峰区检察院防冤止错监督办理王某甲等三人诬告陷害、敲诈勒索案”</a></p>
<blockquote>
<p>2021年6月至11月，王某甲、王某乙、李某某（女，2004年6月出生）共谋，由王某甲、王某乙冒充李某某的成年亲属，由李某某通过社交软件或到酒吧等场所结识男性，以假装醉酒、无处可去等借口引诱男方与其发生性关系，故意在对方身上留下抓痕，后向公安机关报案称被强奸，再由王某甲、王某乙以此为要挟向男方索要财物。王某甲三人采用此种犯罪方式共诬告陷害孙某某等8名被害人，导致其中3人被立案后采取拘留、逮捕强制措施，并对4名被害人敲诈勒索23.7万元，实际非法获取赃款8.7万元。</p>
<p>2023年1月17日，安阳市文峰区法院以诬告陷害罪、敲诈勒索罪分别判处王某甲有期徒刑七年三个月，并处罚金两万元；王某乙有期徒刑七年，并处罚金两万元；李某某有期徒刑六年，并处罚金一万五千元。</p>
</blockquote>
<p>没有强奸那 3 人怎么被采取措施了、那 4 人为何认栽花钱了事？女方诬陷被对方强奸，作为达成目的的手段。有的案件中强奸罪被重重拿起，诬陷罪却被轻轻放下——批评教育罚点钱，甚至被掐灭在萌芽阶段——立案前和解。花钱了事恰恰是大多数男性的选择，反映他们对当前司法现状的认识。疑罪从无是刑事司法的重要原则，但实务中强奸罪往往做有罪推定，这是强奸罪上最大的“常识”，被网友讽刺“以传统社会秩序下的贞洁烈女形象的常识来推定现代社会的强奸罪”。当你发现屋里有一直蟑螂的时候，你家可能已经被蟑螂占领了。这只是发现了的，那些没发现的呢？</p>
<p>以前不理解为何有人要把性生活过程公开拍或偷偷记录？或许有其合理性。4月16号判决一出瞬间懂了，作为男性下意识反应是在这种场景下该如何自我保护。于是抛出一条“暴论”：</p>
<blockquote>
<p>发生关系之前各自录像，双方互相告知且出镜，录到结束，一人一份。无事各自安好，有事起码有证据来保障双方权益。如果女方不愿录像和出镜，除了终止还能怎么办？只能偷拍。</p>
</blockquote>
<p>是不是很离谱？偷拍侵犯对方隐私权，但与强奸罪相比可小太多了。有人会说“南昌锜振东案”你怎么讲？我会说仍然有用。法院判强奸罪是它的权力，起码男方有证据向社会证明事实真相，不会社死。</p>
<blockquote>
<p>南昌锜振东案：女方以男方拒绝建立男女朋友关系为由起诉强奸，学校监控证明事前事后双方举止亲昵，未有强迫之嫌，事中录音证明是男方说太困了想睡觉女方不让，并且女上位可证明不可能是强奸（注：女强男不叫强奸），但法院以女方发生关系是以建立男女朋友关系为前提，男方偷录手段非法证据无效，仍判三缓三。</p>
</blockquote>
<p>近些年消费主义广泛传播、精致利己主义肆意横行、女权主义逐渐兴起、LGBTQ等被关注、民族主义民粹主义抬头。小红书上有专门发教程教怎么从男性身上获取“米”（黑话，钱/财产）骗婚，在实际中却定不了诈骗，最多定“借婚姻索取财物”，返还部分彩礼，被称为“0 成本创业”“致富的办法在刑法和婚家编里”。豆瓣《仙剑奇侠传》讨论区碰到过女权主义对剧中价值观的抨击。且不说那只是艺术作品，单单用现在的尺子衡量20年前的电视剧，捡个锤子就觉得满世界是钉子到处敲，就已经十分可笑。媒体自媒体常常或布下逻辑陷阱，或选择性的以部分事实掩盖全部事实。甚至辟谣辟到最后发现谣言是遥遥领先的预言，官方也经常被打脸。现实情况是网上吃瓜群众大多没有独立思考能力，心智处于8~15岁，容易被煽动而高举“爱国主义”“女权主义”等大旗网暴这个网暴那个。而这些在某种程度上已经成为一种政治正确，政治正确过头也有问题。</p>
<p>网上有一种声音说如果他是订婚强奸案的男方但确实被冤枉，出狱要杀女方和法官全家（法官大多是女性）。跟女权横行有没有关系，他们是在开玩笑吗？去年的湖南省财政厅厅长坠楼，珠海体育馆恶性事件也摆在眼前。用法律的途径来解决，是给法律一个机会，是对法律的一种尊重。不是我必须要求你。是我尊重你，让你来办，你办不好，我有力量自己解决。法律不是万能的，法制只是一种制度，法治也只是一个目标和理念。<strong>现实不是在好苹果和烂苹果之间选，现实往往是在一个烂苹果和另一个更烂的苹果之间选，这就是法治的代价，而这代价，需要所有人来承担</strong>。为什么要“民主”“法治”这种上价值的话，不是要多么好，只是不要太差。“我们之所以一路溃败，是因为过于恐惧”。对于个人来说，如果有选择去港澳台，如果能力足够，去更文明的社会。</p>
<p>二审完毕已经进入执行阶段，离刑期结束只剩一百多天。从博弈的角度看，认罪认罚是最好的选择。男方明确表示要上诉申请再审，实际上只有很低的比例能重启再审，作为一名局外人表示支持。既是为了双方的权益，也为了案件之外的所有人，和司法的公平正义。<strong>能保护自己的，只有法治。司法公正的底线一旦失守，无人能幸免。</strong></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>法律</tag>
        <tag>社会学</tag>
      </tags>
  </entry>
  <entry>
    <title>成都地铁误会偷拍案的反思</title>
    <url>/posts/20250912/</url>
    <content><![CDATA[<p><a href="https://weibo.com/1699432410/Q45mHbokE">成都地铁误会偷拍案二审宣判</a>，官方出了对此案的说明。</p>
<p>第一部分：依据现有证据能证明的事实（部分存疑）。</p>
<p>第二部分：二人给原告道过歉，对方不接受。</p>
<p>第三部分：二人行为不构成法律意义上的“诬陷”。</p>
<p>第四部分：从一般人格权侵权的构成要件解释为何这么判。</p>
<p>疑问：一审中成都地铁是如何把自己摘干净的？车厢内的监控找到了？这部分“事实”是如何证明的。原告无法证明自己无过，而被告成都地铁却因“无证据证明其有过”而免责。</p>
<p>现在尝试从朴素价值观的角度看看。<a href="https://www.thecover.cn/news/3RwWGNKWOG%2BH90qSdq8Jkw==">《事件情况说明》</a> 看标题是在说什么？不懂。看内容是对舆论的回应，而非正式道歉，侧重点不同。建议学学法院怎么写，比如“关于……事件的道歉”。至于说二人已经道歉三次，借用网络热梗“那能一样吗”。</p>
<p>个人的朴素认知有一条：<strong>权责对等</strong>。地铁上质疑被男生偷拍，维护自己权益的同时在公共场合下借社会对女性的偏袒和同情给对方施压。拿了权就得担，事情查清了，那就在地铁这种公众场合道歉呗，对方接不接受那是他的权利。再不行，网上道歉和涉事地铁站张贴多张道歉声明。男生的核心诉求不就是“赔礼道歉，恢复名誉，消除影响”十二个字，其它诉求以当前司法现状也不会支持。</p>
<p>第二条：<strong>法律不是万能的</strong>。这种“小题大做”的案子，为何历经数次调解一审二审？案子可以结，事却未了。求助于法律，结果是“抱歉，法律帮不了你”。凸显现行法律体系在处理此类复杂社会冲突时的局限，导致部分当事人难以获得有效救济。什么法院多么忙，法官多么辛苦有什么可讲的，不过是司法系统在道德破产与法律边界模糊下的被动承载。在误判情况下，是否应承担道义上的责任而非法律责任？而这个案子就如同那句“不是你撞的你为何要扶？”它所引发的社会规范重塑，将悄然显现。</p>
<p>第三条：<strong>社会各方力量得互相制衡</strong>。在当前舆论环境下，女生一方几乎无需承担成本，而男生若要维权，则需付出极高代价。5万元的赔偿诉求，实则是试图通过法律手段提高对方的行为成本，以求制衡。之前长沙公交车上<a href="https://weibo.com/1644114654/Q14xEDbFf">女子怀疑遭性骚扰起冲突后被砸伤</a>，并在网络上散布自己被80岁老头性骚扰的相关言论。评论区开玩笑“老人：谁怕谁，信不信我躺这儿”。事实上老人的解决思路是对的，提高对方的成本——能动手就不争辩。在未达成制衡前，类似的事还会不断上演，拭目以待。</p>
<p>第四条：<strong>不支持网络暴力，但支持对等反击</strong>。学法懂法，保护自己。遇到这种事先取证。了解对方惯用套路，有时候以彼之道还施彼身，也不失为一种解决办法。两手都要抓，两手都要硬。不少三观还未确立便被网络女权浸染过深，陷入受害叙事的群体最终反噬自身，可怜又可悲。</p>
<p>历数最近引起广泛讨论的案子，大多跟男女对立、公平正义有关。比如广铁法院的女子持刀伤人被法官共情轻判并包装成知心姐姐拯救无知少女的“正能量”故事，山西大同订婚强奸案、武大杨某媛“被性骚扰”事件……传统社会女性地位低，看看红楼梦就知道了。现代社会对女性赋予特权和照顾，司法上的社会上的，辅以各种明目和解释。初衷是好的为了平权，结果却造成对男性群体的“逆向歧视”和更大的不平等。</p>
<p>一方面是武大杨某媛借社会对女性的照顾和同情煽动舆论对肖某某网暴、不少人借婚姻之名行诈骗之实；一方面是不时就有地铁偷拍侵害权益的报道、农村外嫁女的权益得不到保障等问题。而在许多引起广泛讨论的案子中男性往往陷入“有劲使不上”的被动局面。或许这就是我们不得不面对的复杂现实。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>法律</tag>
        <tag>社会学</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读-HashMap</title>
    <url>/posts/read-source-HashMap/</url>
    <content><![CDATA[<p>HashMap的原理就是用一个数组存储一系列 K-V 结构的 Node 实体，存储位置通过对 key 的 hashCode 计算得到，Node 对象有 next 指针，作为单链表的一个节点。如果发生 hash 冲突，就将新的 Node 插入链表里。链表过长超过阈值的话为了提高查询效率会转为红黑树（JDK 1.8以后）。</p>
<h2 id="成员变量">成员变量</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认初始化容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认负载因子 0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//桶中链表树化的阈值 8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//树转为链表的阈值 6</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//table最小树化容量 64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="comment">//hashmap 中键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">//扩容阈值（容量×载因子）</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">//真正存放数据的地方</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<h3 id="hashMap默认初始化长度是多少？为什么是这么多？">hashMap默认初始化长度是多少？为什么是这么多？</h3>
<blockquote>
<p>默认初始化长度是 1&lt;&lt;&lt; 4，之所以不直接写16，是因为位运算比算术运算效率高，之所以选择16，是为了服务与 index 的计算公式 index = hash &amp; (length - 1)（这里采用与运算和取模的效果一样，但性能更好），初始化长度减1后为15，二进制位1111，和 hash 值运算后的结果等同于 hash 后几位的值，只要 hash 值本身分布均匀，那 hash 算法的结果就是均匀的，从而实现均匀分布。</p>
</blockquote>
<h3 id="为什么树化标准是8个？">为什么树化标准是8个？</h3>
<p>在源码注释中有提到：如果 hashCode 分布良好的话，很少出现链表比较长的情况。理想情况下，链表的长度符合<a href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html">泊松分布</a>。各长度的概率如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 0:    0.60653066</span></span><br><span class="line"><span class="comment"> * 1:    0.30326533</span></span><br><span class="line"><span class="comment"> * 2:    0.07581633</span></span><br><span class="line"><span class="comment"> * 3:    0.01263606</span></span><br><span class="line"><span class="comment"> * 4:    0.00157952</span></span><br><span class="line"><span class="comment"> * 5:    0.00015795</span></span><br><span class="line"><span class="comment"> * 6:    0.00001316</span></span><br><span class="line"><span class="comment"> * 7:    0.00000094</span></span><br><span class="line"><span class="comment"> * 8:    0.00000006</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>当链表长度为8时，概率为0.00000006，概率非常小，红黑树的转换基本不会发生。当然也会有用到：用户使用自己的 hash 算法，导致 hashCode 分布离散很差，链表很长的情况。</p>
<h3 id="为什么树退化为链表的阈值是6个？">为什么树退化为链表的阈值是6个？</h3>
<p>增加一个过渡，防止在临界值时增加/删除一个元素时，在树和链表之间频繁的转换，降低性能。</p>
<h2 id="初始化方法">初始化方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最常用的一个，负载因子0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定初始化容量，负载因子0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定初始化容量和负载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 取二次幂里比指定容量大且最接近的一个，比如指定容量10，则输出16</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将传入的map的键值对复制一份放hashmap里，不常用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hash方法">hash方法</h2>
<p>hash() 方法是 HashMap 的核心方法，算出 key 的 hashCode 后，将算出的结果右移16位，与原 hashCode 按位异或得到 hash 后的值，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么要右移16位？">为什么要右移16位？</h3>
<p>让 hashCode 的高16位也参与运算，增加扰动，减少碰撞冲突，因为大部分元素的 hashCode 在低位是相同的。</p>
<h3 id="相关问题：String的hashCode的实现？">相关问题：String的hashCode的实现？</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说就是给字符串的每一位，按位乘31的n次幂，再相加，用自然溢出来等效取模。选择31因为这个质数不大不小，且可以被虚拟机优化，运算效率更高。<code>i*31 = i*(32-1) = i&lt;&lt;5-1</code></p>
<h2 id="put方法">put方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// tab:引用当前HashMap的散列表</span></span><br><span class="line">    <span class="comment">// p:表示当前散列表的元素</span></span><br><span class="line">    <span class="comment">// n:当前散列表数组长度</span></span><br><span class="line">    <span class="comment">// i:表示路由寻址结果</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 延迟初始化逻辑，第一次调用putVal方法时初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到的桶位为null,将key,valuef封装成node对象，放进去就ok</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 桶位中的元素与当前插入元素的key一致，后续会进行value的替换操作</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果桶位中的元素是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果桶位中的元素是链表，且链表的头元素与要插入的之不一致</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果当前桶的元素计数大于等于树化阈值，则进行树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到一个元素与当前要插入的元素的key一致</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了一致的元素，用新的value替换原来的value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 putVal 方法中为什么要用 <code>i = (n-1) &amp; hash</code> 作为索引运算呢？</p>
<blockquote>
<p>这其实是种优化手段，由于数组的大小永远是一个2次幂，在扩容后，一个元素的新索引要么在原位置，要么在原位置+扩容前的容量。这个方法的巧妙处全在于&amp;运算，&amp;运算只会关注 n-1（n=数组长度）的有效位，当扩容后，n的有效位相比之前会多增加一位（n会变成之前的两倍，所以确保数组长度永远是2次幂很重要），然后只需要判断 hash 在新增的有效位的位置是 0 还是 1 就可以算出新的索引位置，如果是 0，如果是 2，索引就是原索引+扩容前的容量。</p>
</blockquote>
<h2 id="resize方法">resize方法</h2>
<p>resize()方法主要是用来扩容，具体操作是新建一个hash表，然后将旧表中的内容重新散列复制到新表中。源码主要分为2部分：</p>
<ul>
<li>第一部分主要用于判断当前操作的类型（初始化or扩容）并且计算出新生成的表的容量和阈值。</li>
<li>第二部分只用于扩容操作时，将旧表中的元素重新散列放入新表。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩容方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 引用扩容前的哈希表</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;  <span class="comment">// 扩容前table的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;     <span class="comment">// 扩容前的阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 扩容前table数组大小已达到最大值，则不扩容，且扩容条件设置为int最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常情况，新容量在老容量的基础上翻倍，则在阈值上也翻倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// oldCap==0，oldThr&gt;0 说明哈希表中的散列表还未初始化，在使用带参构造的时候会发生</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//oldCap==0，oldThr&gt;0 使用无参构造的时候</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 说明当前桶位有数据</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 方便JVM回收内存</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 当前桶位有一个元素，计算当前元素扩容后的位置</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 判断当前节点已经树化</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 当前是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 低位链表：扩容之后数组的下标位置与当前数组下标位置一致</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 高位链表：扩容之后数组的下标位置 = 当前数组下标 + 扩容前数组长度</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 通过将hash值与 oldCap 相与，将原来的链表拆分为高位链、低位链</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>; <span class="comment">//修改高位链表结尾</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;    <span class="comment">//放进新table</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="get方法">get方法</h2>
<p>get 方法逻辑比较简单，直接看注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一种情况：定位出的桶元素即为要get的数据</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 第二种情况：当前桶位不只一个元素</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前桶位上的为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 当前桶位上是链表，依次匹配</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="remove方法">remove方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 当前桶位上的节点匹配一致</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 是树节点的情况</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 是链表的情况，遍历链表匹配</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                                    (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 匹配到的节点是树，用树的方法移除</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 如果就是当前桶位上的节点，用下一个节点直接覆盖</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// 匹配到的节点是链表，用链表的方法移除</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>用数组或栈实现阻塞队列</title>
    <url>/posts/implement-blocking-queue-with-array-or-stack/</url>
    <content><![CDATA[<h2 id="用数组实现">用数组实现</h2>
<p>参考 JDK 中的实现<code>java.util.concurrent.ArrayBlockingQueue</code>。</p>
<ol>
<li>考虑使用环形数组。用两个指针 <code>putIndex</code>(下一个入队位置)、<code>takeIndex</code>(下一个出队位置)，入队/出队到数组末尾时都从零开始，<code>count</code>统计元素数量，count=0说明队列为空，count=数组容量说明队列已满。</li>
<li>考虑用 lock + Condition.await 实现阻塞和保证线程安全。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items;   <span class="comment">// 存放元素的数组</span></span><br><span class="line">    <span class="type">int</span> putIndex;   <span class="comment">// 下一个入队位置</span></span><br><span class="line">    <span class="type">int</span> takeIndex;  <span class="comment">// 下一个出队位置</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;   <span class="comment">// 不空，可以出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;    <span class="comment">// 不满，可以进</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue1</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"></span><br><span class="line">        items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往队列放元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();<span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果已满，释放锁并阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            <span class="comment">// 如果未满，入队</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="comment">// 唤醒关注未空的线程</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列取元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果已空，阻塞释放锁</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="comment">// 如果未空，出队</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> dequeue();</span><br><span class="line">            <span class="comment">// 唤醒关注未满的线程</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">        items[putIndex] = e;</span><br><span class="line">        <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">            putIndex = <span class="number">0</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">        items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用栈实现">用栈实现</h2>
<p>栈的特点先进后出(FILO)，阻塞队列的特点先进先出(FIFO)，比较别扭不太合适。</p>
<p>硬要做也能做，思路是使用两个栈，一个入栈栈，一个出栈栈。</p>
<ul>
<li>入队操作：将元素入栈栈</li>
<li>出队操作：如果出栈栈不空，直接弹出；如果出栈栈为空，将入栈栈中所有元素依次弹出并进出栈栈，然后出栈栈弹出。</li>
<li>同样用 lock + Condition.await 实现阻塞和保证线程安全。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackBlockingQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;E&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;E&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;<span class="comment">// 不空，可以出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;<span class="comment">// 不满，可以进</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.inStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.outStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="built_in">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">        <span class="built_in">this</span>.notFull = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往队列放元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();<span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果已满，阻塞并释放锁</span></span><br><span class="line">            <span class="keyword">while</span> (inStack.size() + outStack.size() &gt;= capacity)</span><br><span class="line">                notFull.await();</span><br><span class="line">            <span class="comment">// 如果未满，入队</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="comment">// 唤醒挂在未空条件上的线程</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列取元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果已空，阻塞并释放锁</span></span><br><span class="line">            <span class="keyword">while</span> (outStack.isEmpty() &amp;&amp; inStack.isEmpty())</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="comment">// 如果未空，出队</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> dequeue();</span><br><span class="line">            <span class="comment">// 唤醒挂在未空条件上的线程</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        inStack.push(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>精神分析的思路</title>
    <url>/posts/psychoanalytic-approach/</url>
    <content><![CDATA[<p>那些经典精神分析晦涩的基础名词，虽然看了两遍，现在已经忘得差不多了，哈哈哈，那些不重要。</p>
<p>在我看来精神分析给来访指出一条路：<strong>你的种种感觉、种种异常不是没由来的。如果你想，借助精神分析框架下各种方向的理论，会找到你要的答案</strong>。仅此一点，就足以给来访巨大的帮助了。事实上在来访尝试理解理论、理解自己的过程中，人格就被润物无声般的改变。</p>
<p>这就是精神分析与其他技术流派最大的不同，它走了另一条更曲折，但也更坚定的路。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>精神分析</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>读《盐铁论》</title>
    <url>/posts/read-discourses-on-salt-and-iron/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>《盐铁论》读的是<a href="https://book.douban.com/subject/26417290/">中华书局的版本</a>，书中记录的是西汉汉昭帝时的一场盐铁政策辩论会，辩论一方是御史大夫桑弘羊，文学贤良是另一方。桑弘羊在汉武帝时就主推的盐铁官营、酒类专卖、均输、平准、算缗、告缗、铸五铢钱等政策被文学贤良一方针锋相对。政治、经济、文化、军事、外交也都有涉及，从每章节标题就可以看得出来。最初是作为经济学入门来读，现在这种辩论已经很难看到了。</p>
<h2 id="摘录">摘录</h2>
<blockquote>
<p>夫导民以德，则民归厚；示民以利，则民俗薄。</p>
</blockquote>
<p>这是文学说的，有道理，但实际情况是君主往往根据需要调整，台面上说的和台面下做的并不一致，实用主义。比如以儒家来教化民众，因为儒家思想有利于统治。也有所谓的“外儒内法”一说。</p>
<blockquote>
<p>开委府于京师，以笼货物。贱即买，贵则卖。是以县官不失实，商贾无所贸利，故曰平准。</p>
</blockquote>
<p>高卖低买来平抑物价。</p>
<blockquote>
<p>富在术数，不在劳身；利在势居，不在力耕也。</p>
</blockquote>
<p>振聋发聩！</p>
<blockquote>
<p>如今世俗败坏，竞相奢侈浪费，妇女手工制品要求极其精细，工匠制品要求极其奇巧，雕琢素朴的东西，崇尚珍奇怪物，开山凿石来寻找金银，潜入深水来寻求珠玑，设置机关陷阱来捕捉犀牛大象，张设网罗来猎捕翡翠，寻求边远蛮荒地区的宝物来迷乱中国，转运邛、筰的货物，到达东边沿海地区，交流万里之外的财物，耽误时日，耗费功效，无益于实用。所以平民夫妇，忙得精疲力竭，却衣食不足。</p>
</blockquote>
<p>以现在的眼光看有点迂腐。</p>
<blockquote>
<p>故山泽无征，则君臣同利。</p>
</blockquote>
<p>有点勉强，文学的天真。</p>
<blockquote>
<p>币数变而民滋伪。</p>
</blockquote>
<p>通过发行新币来攫取民间财富，民众愈穷苦，则“滋伪”，饥寒起盗心。</p>
<blockquote>
<p>上好礼则民闇饰，上好货则下死利也。</p>
</blockquote>
<p>楚王好细腰，宫中多饿死。</p>
<blockquote>
<p>算不及蛮、夷则不行。</p>
</blockquote>
<p>把政策想清楚影响和后果，再发布和施行。</p>
<blockquote>
<p>权利深者，不在山海，在朝廷；一家害百家，在萧墙，而不在朐邴也。</p>
</blockquote>
<blockquote>
<p>当世之工匠，不能调其凿枘，则改规矩，不能协声音，则变旧律。</p>
</blockquote>
<p>用来看现在一点不为过，A股为了到达3000点修改指数、统计局为了失业率好看修改统计口径……比比皆是。</p>
<blockquote>
<p>原文：故任能者责成而不劳，任己者事废而无功。</p>
<p>译文：因此任用贤能的人，责其完成任务，自己不会劳苦；只信任自己的人导致事业荒废，没有功效。</p>
</blockquote>
<p>李作为一个温和改革派中后期被架空，搞经济的专业人士被架空，不胜唏嘘。</p>
<blockquote>
<p>如今在位的公卿，既不能像燕昭王那样礼贤下士，像《诗经·小雅·鹿鸣》那样娱乐贤人，又亲身施行臧文仲、子椒的做法，嫉贤妒能，抬高自己的才智，诋毁他人的才能，自满自得，不肯向他人请教，轻视贤士，不愿与贤士做朋友，倚仗自己的地位，凌驾于贤人之上，以自己优厚的俸禄在贤士面前骄傲，却要求士人为己所用，这当然是很难的了！</p>
</blockquote>
<blockquote>
<p>原文：大抵逋流，皆在大家，吏正畏惮，不敢笃责，刻急细民，细民不堪，流亡远去；</p>
<p>译文：大抵逃税的都是豪强大户，地方官员害怕他们，不敢深责他们交税，于是就更加苛刻地急催小民，小民忍受不了，于是流亡到远方。</p>
</blockquote>
<p>土地兼并，生产资料流转到豪强和有权势的人手中。</p>
<blockquote>
<p>陛下富于春秋，委任大臣，公卿辅政，政教未均，故庶人议也。</p>
</blockquote>
<p>这个指摘可以的，现在谁还敢这么说，分分钟禁言。</p>
<blockquote>
<p>非人主用心，好事之臣为县官计过也。</p>
</blockquote>
<p>前面大夫以君主为盾，文学以史为鉴迂回战术直言好事之臣的锅，这辩论技巧。</p>
<blockquote>
<p>原文：大夫曰：“挟管仲之智者，非为厮役之使也。怀陶硃之虑者，不居贫困之处。文学能言而不能行，居下而讪上，处贫而非富，大言而不从，高厉而行卑，诽誉訾议，以要名采善于当世。夫禄不过秉握者，不足以言治，家不满檐石者，不足以计事。儒皆贫羸，衣冠不完，安知国家之政，县官之事乎？何斗辟造阳也！”</p>
<p>译文：大夫说：“拥有管仲智慧的人，不会担任奴仆的职务。怀藏陶朱公思虑的人，不会居住在贫困的处所。文学能说而不能行，居下位而诽谤上司，身处贫困而非难富有，说大话而做不到，外表清高却行为卑鄙，诽谤他人声誉，妄发议论，以此向当世求取好名声。俸禄不过一束禾一把米的人，不足以谈论国家治理，家产还不到一石粮的人，不足以筹划朝廷大事。儒生们都很贫苦，衣冠尚且不完备，怎么知道国家大政、朝廷之事呢？还侈谈什么绝险僻远、舍弃造阳的事！”</p>
</blockquote>
<p>大夫的言辞犀利态度傲慢。从现实角度看，能言不能行，解决不了问题白搭。</p>
<blockquote>
<p>古之君子，守道以立名，修身以俟时，不为穷变节，不为贱易志，惟仁之处，惟义之行。临财苟得，见利反义，不义而富，无名而贵，仁者不为也。</p>
</blockquote>
<p>不为也，说的没毛病。从另一个角度看，也可以说文学在抱残守缺，时代在变，人也在变。</p>
<blockquote>
<p>未有不能自足而能足人者也。未有不能自治而能治人者也。</p>
</blockquote>
<blockquote>
<p>大夫曰：“所谓文学高第者，智略能明先王之术，而姿质足以履行其道。故居则为人师，用则为世法。今文学言治则称尧、舜，道行则言孔、墨，授之政则不达，怀古道而不能行，言直而行枉，道是而情非，衣冠有以殊于乡曲，而实无以异于凡人。诸生所谓中直者，遭时蒙幸，备数适然耳，殆非明举所谓，固未可与论治也。”</p>
</blockquote>
<p>大夫批驳对方解决不了实际问题，只用孔孟之道高谈阔论。</p>
<blockquote>
<p>文学曰：“天设三光以照记，天子立公卿以明治。故曰：公卿者，四海之表仪，神化之丹青也。上有辅明主之任，下有遂圣化之事，和阴阳，调四时，安众庶，育群生，使百姓辑睦，无怨思之色，四夷顺德，无叛逆之忧，此公卿之职，而贤者之所务也。</p>
</blockquote>
<p>文学要求公卿怎样怎样，上劝谏君王，下教化百姓，要所有人做圣人，其实是做不到的。</p>
<blockquote>
<p>原文：塞士之涂，壅人之口，道谀日进而上不闻其过，此秦所以失天下而殒社稷也。</p>
<p>译文：堵塞士人进身道路，堵住民众的嘴巴，说奉承话的人步步高升，皇上听不见过错，这就是秦王朝失去天下、毁灭社稷的原因啊。</p>
</blockquote>
<p>阶级固化，给民众发口罩眼罩，张维为之流被搬上台面，是丧失信心的原因之一。</p>
<blockquote>
<p>饭蔬粝者不可以言孝，妻子饥寒者不可以言慈，绪业不修者不可以言理。</p>
</blockquote>
<p>别整天讲那些大道理，过好自己的生活是根本。</p>
<blockquote>
<p>言者不必有德，何者？言之易而行之难。</p>
</blockquote>
<blockquote>
<p>况且《诗经·小雅》批评他人，一定会拿出办法来替代弊政。</p>
</blockquote>
<blockquote>
<p>百姓或短褐不完，而犬马衣文绣，黎民或糟糠不接，而禽兽食粱肉。</p>
</blockquote>
<p>文学直言贫富差距悬殊。</p>
<blockquote>
<p>贤良认为导致国家财政匮乏的根本原因是权贵阶层的豪奢之风，要求公卿大夫子孙做到节制车马，衣着适当，亲身节俭，以敦厚朴实作为民众表率，罢弃园林池苑，减少良田豪宅。</p>
</blockquote>
<p>敲在了鼓边。儒家那一套，要求每个人怎样怎样。浪漫的理想主义，做不到就是空想。</p>
<blockquote>
<p>在朝政腐败形势下要想百官廉洁，是不可能的。要想影子正，先端正标杆，要想下级廉洁，长官先要自身做表率。因此贪污粗鄙根源在长官而不在下级，教诲训示的重点在朝政而不在民众。</p>
</blockquote>
<p>“其身正，不令而行；其身不正，虽令不从”。说不上有多大效果，但做比不做好。</p>
<blockquote>
<p>大夫首先指出，部分民众贫穷是由于他们懒惰造成的，朝廷不应该同情此类懒惰之人。</p>
</blockquote>
<p>与“农民没有交过社保，老时自然没有多少养老金”、&quot;不能发钱，发钱养懒汉&quot;的论调何其相似。</p>
<blockquote>
<p>贤良认为，鼓励农耕关键在于不误农时，而不是搞一些悬挂青旗、鞭策土牛的劝农形式。</p>
</blockquote>
<blockquote>
<p>《老子》曰：‘上无欲而民朴，上无事而民自富。’</p>
</blockquote>
<p>上面不瞎折腾，民众努力创造财富自然会富起来。整天形式主义各种开会出政策，虚头巴脑，毫无用处。也不全是，唯一的用处大概是宣传我们也是做了很多事情的。</p>
<blockquote>
<p>原文：不轨之民，困桡公利，而欲擅山泽。从文学、贤良之意，则利归于下，而县官无可为者。上之所行则非之，上之所言则讥之，专欲损上徇下，亏主而适臣。</p>
<p>译文：一些不守法的庶民，困扰削弱国家利益，想占有山泽资源。如果顺从文学、贤良的意见，那么山泽资源利益就会归于下民，朝廷就没有什么作为了。朝廷所推行的政策你们就非难，朝廷官员说话你们就反唇相讥，一心想损害朝廷，谋取下层利益，亏损君主，迎合臣民。</p>
</blockquote>
<p>有所作为？政府喜欢凯恩斯那一套，从结果看是加强管控，民生凋敝。</p>
<blockquote>
<p>公曰：‘天寒哉？我何不寒哉？’人之言曰：‘安者不能恤危，饱者不能食饥。’故余粱肉者难为言隐约，处佚乐者难为言勤苦。</p>
</blockquote>
<p>何不食肉糜。专家的“房子租出来就有收入”“稳中向好”……把这类专家的津贴减半，精简体制人员，减轻纳税人负担。</p>
<blockquote>
<p>夫高堂邃宇、广厦洞房者，不知专屋狭庐、上漏下湿者之癐也。系马百驷、货财充内、储陈纳新者，不知有旦无暮、称贷者之急也。广第唐园、良田连比者，不知无运踵之业、窜头宅者之役也。原马被山，牛羊满谷者，不知无孤豚瘠犊者之窭也。高枕谈卧、无叫号者，不知忧私责与吏正戚者之愁也。被纨蹑韦、搏粱啮肥者，不知短褐之寒、糠謪之苦也。从容房闱之间、垂拱持案食者，不知蹠耒躬耕者之勤也。乘坚驱良、列骑成行者，不知负檐步行者之劳也。匡床旃席、侍御满侧者，不知负辂挽舩、登高绝流者之难也。衣轻暖、被美裘、处温室、载安车者，不知乘边城、飘胡、代、乡清风者之危寒也。妻子好合、子孙保之者，不知老母之憔悴、匹妇之悲恨也。耳听五音、目视弄优者，不知蒙流矢、距敌方外者之死也。东向伏几、振笔如调文者，不知木索之急、棰楚者之痛也。坐旃茵之上，安图籍之言若易然，亦不知步涉者之难也。</p>
</blockquote>
<blockquote>
<p>双方论争的实质是王霸之争，即究竟是以仁德感化还是以武力征伐的方式来处理夷夏矛盾。</p>
</blockquote>
<p>站当时情形看，当恩威并施。理解为对少数民族的政策，亦如是。</p>
<blockquote>
<p>辔衔者，御之具也，得良工而调。法势者，治之具也，得贤人而化。执辔非其人，则马奔驰。执轴非其人，则船覆伤。</p>
</blockquote>
<blockquote>
<p>故世不患无法，而患无必行之法也。</p>
</blockquote>
<p>法律得不到落实和执行依然没有用。</p>
<blockquote>
<p>民之仰法，犹鱼之仰水，水清则静，浊则扰；扰则不安其居，静则乐其业；乐其业则富，富则仁生，赡则争止。</p>
</blockquote>
<h2 id="提问">提问</h2>
<h3 id="为何要读？">为何要读？</h3>
<p>前年读了几本经济学的书，很受启发。有网友推荐《盐铁论》作为经济学入门，看着挺有趣，便加到待看书单。</p>
<h3 id="读一年之久？书该怎么读？">读一年之久？书该怎么读？</h3>
<p>开始读还挺带劲，而后用典慢慢增多，看的晕头转向。上学时被文言文支配的感觉上来了，两章之内必睡着，堪称催眠入睡神器。这种情况读了几个月，五百多页的书没多少进展，决定换一种方法。读这本书的目的，于我而言是经济学入门，了解讲的内容就行，没必要深究。看标题题解，通读原文，放弃各种注释，直接看译文。</p>
<p>书该怎么读？</p>
<ul>
<li>选自己感兴趣的书。</li>
<li>读不进去不要硬读，或许只是当前阶段不太匹配这本书。</li>
<li>确定读这本书的目的。</li>
<li>最好读完提几个问题，试着回答。</li>
</ul>
<h3 id="有什么感受？">有什么感受？</h3>
<p>很多地方感觉文学说的在理，可能因为传统教育就是以儒家思想为底子。什么三纲五常，本质上是要求每个人：执政者要怎样、官吏要怎样、家庭中要怎样、平民百姓要怎样。太理想主义，其实是做不到的。相比之下桑弘羊一方更实际，能解决问题。看看自己身上理想化的部分，等到实际去解决问题，发现完全不是那么回事。而且因为长久以来接受的是不完整的儒家思想，往往会被这些条条框框束缚限制自身发展。</p>
<h3 id="没有变的是什么？">没有变的是什么？</h3>
<p>文学贤良来自民间，对盐铁政策下出现的各种问题看的清楚，诸如流民失地、贫富差距悬殊、腐败，但没有能力改变。主导盐铁政策的桑弘羊重点在解决具体问题，但态度傲慢并不了解底层之苦。这不是跟现在一模一样嘛。</p>
<p>看似是文学贤良一方取得暂时的胜利，但朝廷仅接受文学贤良部分建议废除酒类专卖，其他政策依旧施行，甚至就是文学贤良的支持者霍光施行的。盐铁辩论之后，民众的生活并没有什么改善。</p>
<p>从经济学角度来看，桑弘羊主张的是大政府，资源管制，集中力量办大事。文学贤良一方倡导自由主义经济，放松资源管制，藏富于民。暴露的问题和其中的经济学规律，现在看也并未过时。</p>
<p>我们能做什么？了解其中规律，在此之下做出正确决策，过好自己的生活。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>读《薛兆丰经济学讲义》</title>
    <url>/posts/read-xuezhaofeng-economics-lecture-notes/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>经济学入门，门槛比较低。</p>
<h2 id="摘录">摘录</h2>
<blockquote>
<p>经济学不难明白，也不难背诵，难在一刻不忘地运用。</p>
</blockquote>
<blockquote>
<p>人类面临着四大基本约束：东西不够，生命有限，互相依赖，需要协调。</p>
</blockquote>
<blockquote>
<p>公平背后往往是效率的考量，不是单个人效率的考量，而是整体社会长远发展的效率的考量。</p>
</blockquote>
<blockquote>
<p>经济学是一门研究个人如何致富、国家如何富强的学问。</p>
</blockquote>
<blockquote>
<p>经济学关心的是存活的条件。也就是说，经济学研究的是在什么样的情况下，人能够存活下来，而如果条件发生了改变，人们存活的情况又会发生怎样的改变。</p>
</blockquote>
<blockquote>
<p>斯密的第一个观点是：人是自私的，那些完全不自私的人，连自己都不爱的人，自暴自弃的人，在社会上是不会受到尊重的。<br>
斯密紧接着说了第二个观点：人不仅仅是自私的，同时还具有同情心，也就是有一种设身处地为他人着想的能力。人们把自己认为的别人是否幸福，当作自己是否幸福的一部分：你幸福，我幸福；你痛苦，我也感到痛苦。这是一种天生的能力，叫“同情心”，人人都有。人有同情心，也就是有爱心。</p>
</blockquote>
<blockquote>
<p>斯密的第三个观点是：“人的同情心是随着人与人之间距离的拉远而急速减弱的。”</p>
</blockquote>
<blockquote>
<p>小圈子靠爱心、讲同情，而大世界靠市场、讲规则。斯密的重要建议是：不要搞混了，不要在家庭、朋友圈里斤斤计较，过分讲究市场规则，也不要在市场上强求陌生人表现出不切实际的爱心。</p>
</blockquote>
<blockquote>
<p>为了消除歧视，却产生了新的歧视，我们称之为逆向歧视。</p>
</blockquote>
<p>国内饱受诟病的高考加分政策、少数民族政策、系统性向女性倾斜并把这种做法当做“进步”的表现……过犹不及。</p>
<blockquote>
<p>既然歧视是不可避免的，那么谁进行了歧视，谁就要承担歧视的后果。</p>
</blockquote>
<blockquote>
<p>所谓租，就是对资产的付费。</p>
</blockquote>
<blockquote>
<p>在经济学界，“寻租”这个词则专指后者的行为，即那些向政府争取优惠政策，让自己得到好处，同时导致社会总资源发生耗散的行为。</p>
</blockquote>
<blockquote>
<p>一项有价值的资源，不管一开始它的产权归谁，最后这项资源都会流动到最善于利用它、能最大化其价值的人手里。这是科斯定律的一个重要含义。</p>
</blockquote>
<blockquote>
<p>我们应当充分领会科斯定律的精神，在现实生活的各种冲突中积极地寻找合作解。</p>
</blockquote>
<blockquote>
<p>需求第一定律是说：当其他情况不变时，只要价格提高，商品的需求量就会减少；价格降到一定程度，需求量就会增加。</p>
</blockquote>
<blockquote>
<p>需求第二定律是说：需求对价格的弹性，和价格变化之后流逝的时间长度成正比。也就是说，随着时间的推移，需求对价格的弹性会增加。</p>
</blockquote>
<blockquote>
<p>税负是双方共同承担的；双方各付多少，取决于需求者和供应者双方的相对弹性，谁的弹性低，谁对这份交易的需求更迫切，谁就付得多一点。</p>
</blockquote>
<blockquote>
<p>需求第三定律的含义：每当消费者必须支付一笔附加费时，高品质的产品相对低品质的产品就变得便宜了，这笔附加费越高，高品质产品相对就越便宜。正因为这样，我们也把这个定律叫作“好东西运到远方去定律”。</p>
</blockquote>
<blockquote>
<p>一个社会如果把个人的权利置于公平之上的话，那么这个社会运行的结果，当然不会是公平的，但是它却离公平很近。而另一种社会，如果把追求公平放在追求个人权利之上，这个社会就既不能保证个人的权利，也不能达到所谓的公平。因为每当你要追求公平的时候，肯定会出现的结果，就是甲和乙两个人商量，怎么逼着丙去替丁做一些事情，而甲和乙还从中分一杯羹。</p>
</blockquote>
<p>精辟</p>
<blockquote>
<p>只要过时的观念和既得利益缠住了相当多的人群，任何激进和彻底的改革在实际中都寸步难行。</p>
</blockquote>
<p>现在就是如此</p>
<blockquote>
<p>权利是通过社会强制而实现的，是别人授予我们的；不是我们自己认为有就有，而是别人认为我们有才有；要别人愿意出来保护我们行使的自由，才能叫权利。这是权利的特征。</p>
</blockquote>
<blockquote>
<p>能力取决于自己能够占有多少，而权利则取决于社会上其他人愿意给你多少。</p>
</blockquote>
<blockquote>
<p>权利需要社会上其他人的共同认可和执行。</p>
</blockquote>
<p>国内肆虐的女权大概以为她们的权是权力的权，不是权利的权，不免让人耻笑。</p>
<blockquote>
<p>产权：使用权、收益权和转让权。</p>
</blockquote>
<blockquote>
<p>产权保护有三个基本原则——财产原则、责任原则和不可转让原则。</p>
</blockquote>
<blockquote>
<p>这是经济学家讨论拥堵问题的切入视角，他是从资源怎样才能发挥最大的经济效益这个角度来切入的。<br>
道路要保持适当的拥挤，而什么才叫适当呢？当道路的经济价值发挥到最大时，道路的拥堵程度就算是适当的拥堵。这一点由谁来判断呢？由道路的主人来判断，由道路的主人来追求，由道路的主人来摸索。</p>
</blockquote>
<blockquote>
<p>拥堵费收了以后，政府能不能善用拥堵费是一回事（我们当然希望这笔钱能够得到善用），该不该收拥堵费是另一回事。</p>
</blockquote>
<p>逻辑清晰</p>
<blockquote>
<p>因为利率是人们推迟消费时索取的一种补偿，所以未来越是不确定利率就越高。</p>
</blockquote>
<blockquote>
<p>我们知道，由于穷人还款的能力不高，有钱人是不太愿意把钱借给穷人的，这时如果收取的利息更低，他们就更不愿意借了。而政府规定的这种低利率，特别是低于市场标准的利率，实际上更容易被那些有钱、有势、有关系的人享用，穷人反而拿不到。</p>
</blockquote>
<p>赈灾粮中掺沙子，灾民才更有可能获得救济。</p>
<blockquote>
<p>经济学里有一个基本规律：所有资产的回报率都会趋向于相等。</p>
</blockquote>
<blockquote>
<p>在竞争之下，任何资源所能够获得的回报，会接近于这个资源本身所能带来的边际收入。</p>
</blockquote>
<blockquote>
<p>这些国家的养老保险实际上不是一种可持续的商业保险，而是一种不断地靠新人来维持的补贴制度，已经一步步走向破产的边缘了。</p>
</blockquote>
<p>我们要面对的现实</p>
<blockquote>
<p>一个国家如果在它还不够强大的时候就打开国门，它的很多行业，就会受到国外更强的竞争者的冲击，就会产生企业倒闭和工人失业的问题，所以我们是不是应该等到国力加强了以后，才打开国门呢？</p>
</blockquote>
<p>因果倒置</p>
<blockquote>
<p>反对自由贸易还有一种观点，是认为我们应该把钱留在本地，把钱留给自己人赚，别让外人给赚了。</p>
</blockquote>
<p>肥水不流外人田</p>
<blockquote>
<p>工作是一种机会，人们只会选择那些有价值的工作来做</p>
</blockquote>
<blockquote>
<p>对于美国工人而言，在新的国际分工和合作的格局当中，他们应该找到自己的位置，不断地学习，进一步突破劳动力市场的各种限制，这才是他们提高竞争力的正确方向。</p>
</blockquote>
<p>对于我们也是如此</p>
<blockquote>
<p>人和人之间本来是没有互信的，高品质的产品要把自己彰显出来，与低品质的产品区分开来，需要很大的成本。如果这个问题不解决，就会出现劣币驱逐良币的现象。当消费者无法分辨哪一件是高品质产品、哪一件是低品质产品时，他们就会离场，卖家也同样会离场，市场就会崩溃。</p>
</blockquote>
<p>相亲市场</p>
<blockquote>
<p>损失掉一部分品牌的多样性，换来的是稳定性和可靠性，这么做可能是现代社会提高产品质量可靠性的一种趋势。</p>
</blockquote>
<p>从诺基亚时期各种型号的手机到苹果时期只做一两款</p>
<blockquote>
<p>一夫一妻制实际上就是一种对成功男人限购的政策，它的效果是财富转移。它让女人的选择范围减少了，让成功的、更有吸引力的男人的选择减少了，而让那些年纪较轻、收入较低的男人处境变好了。</p>
</blockquote>
<blockquote>
<p>工作越不好找，这个行业允许新人进来的门槛就越高。</p>
</blockquote>
<blockquote>
<p>那么穷人怎么办？最重要的出路就是自强，增加自身的人力资本投资，提高自身的素质。简单地说就是要不断学习、终身学习。</p>
</blockquote>
<blockquote>
<p>奥地利学派里有一个重要的概念叫“自发秩序”（spontaneous order），它的意思是，我们今天在社会上看到的秩序，不是由哪一个个人或者哪一个权威机构一厢情愿地设计出来的，它是由无数人的行动汇合而成的。</p>
</blockquote>
<p>女权肆虐后网上各种言论动不动就“父权”如何如何。你去问她们什么是“父权”，哑口无言。</p>
<blockquote>
<p>货币代表着机会，多挣钱不代表人们爱的只是钱，钱多只代表人的机会更多、选择更多。</p>
</blockquote>
<p>醍醐灌顶</p>
<blockquote>
<p>凯恩斯主义学派的基本主张是，政府应该逆经济周期而行，人们都在消费时政府就少采取动作；人们都不消费时，政府就应该积极消费、积极投资、积极生产。</p>
</blockquote>
<blockquote>
<p>凯恩斯本人其实是深信市场自行调节功能的，他指出一旦社会回到正常的状态，政府就应该停止干预，让市场机制自己发挥作用。换句话说凯恩斯主义者关心的是要解决短期内出现的问题，尤其是短期内出现的失业问题，这时创造需求、制造就业机会就是政府的责任。</p>
</blockquote>
<blockquote>
<p>每一个政党都有非常复杂的政纲，这些政纲涉及政治、经济、文化、外交、军事等各个方面。人们要做的公共选择的数量哪怕不是无限的，也是非常庞大的。<br>
但是，人们实际上不可能有足够的精力和金钱，来对这些选择逐一投票。所以政治的现实是，人们只能够在若干个数量极其有限的套餐里做一个选择，而最后能够脱颖而出参加政治选举的政党数目不会太多，通常是两个，三四个已经很多了。人们不可能全盘接受任何一个候选人、候选政党的全部政纲，只能妥协。<br>
这些妥协本身就是一个人内心的选票买卖的过程：哪件事更重、哪件事更轻，哪件事值得坚持、哪件事可以放弃，我们在内心已经做了一番权衡。</p>
</blockquote>
<blockquote>
<p>两位作者洋洋洒洒写了厚厚的一本书，总结出来的就是这两个没有经过严格定义的概念。这两个概念看上去非常强大，能解释所有的现象，但仔细分析我们就能发现，它们的任何一种含义我们都能够找到反例。</p>
</blockquote>
<p>说的是《国家为什么会失败：权力、繁荣和贫穷的根源》。它的意义不在于是不是精确推导出的结论，而在于“原来不止我一个人这么想”。这么想的人多了，就会用脚投票。</p>
<blockquote>
<p>如果价格不能指导分配，那么价格前面的两项功能也就会失效，价格就没办法传递关于稀缺的信息，也没办法指导生产了。如何分饼会决定饼能做多大。</p>
</blockquote>
<blockquote>
<p>什么才是地道的经济学思维？<br>
地道的经济学思维，是对包含人性的因果规律的探索。在这个探索过程中，数字不重要，术语不重要，结论也不重要；是想象力重要，是视角重要，是推理重要，而权衡更重要。</p>
</blockquote>
<blockquote>
<p>过去人们认为有良好的愿望就能成功，从经济学的角度看，往往是人们成功了才去找理由，这是对因果关系的一个颠覆。</p>
</blockquote>
<blockquote>
<p>经济学是一门研究人的行为规律的学科，要找出人的行为规律，就不仅要找出各种事件之间的相关性，还要确定它们之间的因果关系。人们对不同事件之间的因果关系存在这样那样的偏见甚至是误解，而经济学分析可以修正这些偏见和误解。</p>
</blockquote>
<blockquote>
<p>我们要重视那些经济发展的内在的不可抗拒的规律，要做那些顺应这些规律的人，不论提出什么样的说法、理论、口号，语言都不重要，语言所包装的行为是否符合经济发展规律才是重要的。</p>
</blockquote>
<h2 id="提问">提问</h2>
<p>书中每一节都有相关的提问，这里只是摘出来一部分我的答案。</p>
<p><strong>请举一个例子，人们出于美好的愿望，却产生了事与愿违的结果的？</strong></p>
<p>出政策抑制高房价，却成为房价推手之一。</p>
<p><strong>人们的歧视行为，是在选总统的时候更严重，还是在选伴侣的时候更严重？</strong></p>
<p>选伴侣，因为会切实影响到自身。</p>
<p><strong>有哪件物品，市场上的价格很低，而你对它的个人估值却是非常高的？</strong></p>
<p>当你非常需要某件物品的时候。</p>
<p><strong>租房买房是我们生活中一个很大的开销，如果住房不搞市场化，改为政府给我们分房的话，那么我们的住房条件会变得怎么样？</strong></p>
<p>大多数普通人将住不到房。</p>
<p><strong>我们在市场上能买到的牛奶，里面的蛋白质含量有高有低，如果政府规定所有牛奶的蛋白质含量必须达到一个最低的标准，这样的规定会导致什么样的后果？</strong></p>
<p>有人蛋白质含量低牛奶卖不出去，有人喝不到牛奶。</p>
<p><strong>在一个经常罢工的国家比较容易找到工作，还是在一个不经常罢工的国家比较容易找到工作？</strong></p>
<p>根本因素是供需关系，是不是经常罢工只是次因。</p>
<p><strong>通货膨胀只不过是货币数量不断地增加而已，而货币本身只不过是一个记账的符号，如果每个人的工资、收入、支出都加一个零的话，那对真实生活会有影响吗？为什么？</strong></p>
<p>物价上涨，贫者愈贫，富者愈富，差距进一步拉大。举个例子，养老金每年普调百分之几，这么多年差距是变小还是变大？现实情况是差距更大了。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>电信机顶盒无线改造</title>
    <url>/posts/wireless-retrofit-for-telecom-STB/</url>
    <content><![CDATA[<h2 id="场景">场景</h2>
<p>原本电信光猫 iTV 口接盒子，在盒子里认证输出 IPTV 信号给客厅电视，光猫的 LAN 口接无线路由器在路由器中拨号用来上网，如下图。现<strong>需要在卧室看电视</strong>，但是卧室没布线，考虑使用无线。</p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/20210221095537.png" alt="原网络拓扑"></p>
<h2 id="设备清单">设备清单</h2>
<ul>
<li>电信天翼E家光纤猫（有WIFI模块，GPON天翼网关，华为定制，型号：EchoLife HS8145C）</li>
<li>电信机顶盒（IPTV盒子，有WIFI模块，烽火定制，型号HG680，个人猜测相似的型号 HG680-J 等只是固件不同，硬件条件都一样）</li>
<li>无线路由器</li>
<li>客厅电视（WIFI或者网线连接均可）</li>
<li>卧室电视（使用之前的到手的显示器 + 小音箱作为电视）</li>
</ul>
<h2 id="改造过程">改造过程</h2>
<h3 id="获取必要信息">获取必要信息</h3>
<ul>
<li>获取光猫配置地址、光猫WIFI名和密码（或者直接网线接 Lan 口）</li>
<li>获取光猫超级管理员账号密码，网络搜索可得，用户名：telecomadmin   密码：nE7jA%5m（仅适用于华为定制的电信光纤猫部分型号）</li>
<li>获取机顶盒设置密码：10000（如果不对，尝试6321、8288、10086、10010）</li>
</ul>
<h3 id="IPTV走无线网络">IPTV走无线网络</h3>
<p>参考<a href="https://zhuanlan.zhihu.com/p/27008904">改造“电信天翼E家”有线IPTV为无线</a>一文，访问光猫配置地址，使用超级管理员账号密码登录，可以查看到 iTV 端口桥接（连接名称：3_OTHER_B_VID_43），其他端口包括无线 WIFI 桥接上网，改造的思路：将无线网络也绑定到 iTV 业务。</p>
<p>在“<strong>网络 - 网络设置</strong>”中找到 iTV 的连接，修改“<strong>SSID 端口绑定</strong> ”，勾选“<strong>SSID1(无线网络)</strong>”保存，这样 iTV 端口和 光猫的无线网络都可以使用 IPTV 了。</p>
<p>在“<strong>应用 - IGMP设置</strong>”中启用“<strong>IGMP Snooping</strong>” 选项，这一步非常重要，否则网络中会有 IGMP 泛洪，导致观看 IPTV 时卡成 PPT😭，同时别的设备无法上网。</p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/20210221095729.png" alt="新网络拓扑"></p>
<p>按照上图改造网络拓扑，输入维护密码进入设置界面，在“<strong>网络设置</strong>”中选择光猫的无线网络，勾选“<strong>高级选项 - PPPOE</strong>”。正常来说机顶盒激活后，配置信息会写入机器，无需填写 IPTV 的账号密码（如果没有，请在办理电信天翼E家网络及IPTV服务协议上找相关账号及密码认证）。连接后会获取一个 10.*.*.* 的电信的组播 IP，此时卧室电视就可以看了。</p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/20210221114958.jpg" alt="设置界面"></p>
<p>由于显示器没有功放，考虑用蓝牙连接家里的小度音箱，尝试后发现蓝牙失败。网上搜索得知这款烽火 HG680 无蓝牙功能，小度音箱也无法接线输入音频，于是老老实实从家里翻出一个带音频输入线的小音箱，接显示器实现电视功能。</p>
<h3 id="盒子弃用IPTV">盒子弃用IPTV</h3>
<p>在设置网络的时候发现也可以连接路由器的无线网络，但是看不了IPTV，搜索得知 IPTV 只能使用组播网络，但是烽火 HG680 可以刷机或者通过其他手段安装 app，一下子就打开了新世界的大门。于是有了此方案，机顶盒连接路由器的无线网络，弃用 IPTV。</p>
<p><img src="https://blog-1258671016.cos.ap-chengdu.myqcloud.com/image/20210221124526.jpg" alt="电信机顶盒"></p>
<p>各地区类似型号的烽火机顶盒由于固件不同，可能需要不同的方式安装 app</p>
<ul>
<li>电脑和机顶盒处于同一网络下，直接 adb 安装</li>
<li>adb 连接不上，说明 USB 调试模式没打开，参考<a href="https://www.znds.com/forum.php?mod=viewthread&amp;ordertype=1&amp;tid=1174073">电信机顶盒开启ADB方法汇总</a>，如果还不行，则需要通过刷机打开 USB 模式/安装新 app，有风险</li>
<li>通过 <a href="https://www.znds.com/tv-644159-1-1.html">samba 共享</a>的方式将要安装的 apk 包塞到机顶盒中，通过文件浏览安装</li>
</ul>
<p>由于电脑是 deepin，安装 adb 后可以连接，windows 电脑安装 adb 请百度搜索此不赘述</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装adb工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install adb -y</span><br><span class="line"><span class="comment"># ip是盒子的ip，成功后显示Success</span></span><br><span class="line">adb connect 192.168.11.238</span><br><span class="line"><span class="comment"># xxx.apk表示要安装的app，最好使用绝对路径，一般先安装当贝桌面</span></span><br><span class="line">adb install xxx.apk</span><br></pre></td></tr></table></figure>
<p>安装成功后重启机顶盒，开机后一般默认进入当贝桌面。如果还是 IPTV 界面，可以从“应用商城”中找到当贝桌面，打开后设置开机自启。然后安装需要的应用市场/直播/其他 app 即可。毕竟规格不大，不要安装太多，会卡。从当贝桌面也可以进 IPTV，但是使用 IPTV 需要切换为光猫的无线网络。</p>
<h3 id="方案对比">方案对比</h3>
<table>
<thead>
<tr>
<th></th>
<th>方案一：IPTV走无线网络</th>
<th>方案二：弃用IPTV直接使用盒子</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>高清直播，换频道不卡</td>
<td>新世界，自由度高</td>
</tr>
<tr>
<td>缺点</td>
<td>只能使用运营商上提供的资源，很多都要收费</td>
<td>会占用部分上网带宽，直播体验没有IPTV好，可以切换回IPTV，需要切换回光猫的无线网络</td>
</tr>
</tbody>
</table>
<p>经过权衡，使用了方案二，找了个直播软件，差不多可以替换 IPTV，体验不错。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>邮件已读追踪</title>
    <url>/posts/email-read-tracking/</url>
    <content><![CDATA[<h2 id="场景">场景</h2>
<p>最近工作消息模块通过邮件发消息，需要有个邮件已读追踪的功能，即邮件发出去能知道是否已读并记录状态。</p>
<h2 id="思路">思路</h2>
<h3 id="利用阅读回执">利用阅读回执</h3>
<p>阅读回执的原理就是发送邮件的时候，在 header 信息中增加<code>(&quot;Disposition-Notification-To&quot;,&quot;发件人邮箱&quot;)</code>，属于邮件协议的一部分，跟业务没什么关系。接收方打开后会回一封邮件给发送方，表明之前的邮件已读。在实测试中发现接收方可以选择是否发送回执，算是君子协定。</p>
<h3 id="利用图片加载">利用图片加载</h3>
<p>考虑发送时默认在邮件中加一张图片，利用打开邮件时加载图片来实现，也可实现阅读次数统计。网上也有类似的邮件追踪工具，感觉可行，开始干活。</p>
<h2 id="实现">实现</h2>
<p>可以使用 logo 或者 1*1px 的透明图片，插入到邮件中的效果如下，12345 为消息记录的id，用来与业务对应</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://域名/track?msgId=123456&quot;</span> <span class="attr">id</span>=<span class="string">&quot;track&quot;</span> <span class="attr">style</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>img 标签加载时是 get 请求，后台写个方法用来接请求的参数，pom 依赖和 controller 内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrackingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/track&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; getImage(<span class="meta">@RequestParam(&quot;msgId&quot;)</span> String msgId) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//保存消息状态/计数，这里直接打印出来</span></span><br><span class="line">        System.out.println(<span class="string">&quot;消息ID：&quot;</span> + msgId);</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassPathResource</span> <span class="variable">img</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/ifread.png&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] imageBytes = Files.readAllBytes(img.getFile().toPath());</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        headers.setContentType(MediaType.IMAGE_PNG);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().headers(headers).body(imageBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经测试，可以拿到参数 msgId，如需要也可获取 IP 等其他信息。</p>
<h2 id="优点和局限性">优点和局限性</h2>
<p>优点：</p>
<ul>
<li>实现简单，没有太多代码和逻辑。</li>
<li>不需要对方确认，强制追踪阅读情况。</li>
</ul>
<p>局限性：</p>
<ul>
<li>在某些特定的网络/系统/客户端限制访问图片的链接，可能无法生效。</li>
<li>因为对方不知情，可能涉及隐私的问题。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
